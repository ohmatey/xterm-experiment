{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Buffer_1 = require(\"../Buffer\");\n\nvar Types_1 = require(\"./Types\");\n\nvar GridCache_1 = require(\"./GridCache\");\n\nvar BaseRenderLayer_1 = require(\"./BaseRenderLayer\");\n\nvar OVERLAP_OWNED_CHAR_DATA = [null, '', 0, -1];\n\nvar TextRenderLayer = function (_super) {\n  __extends(TextRenderLayer, _super);\n\n  function TextRenderLayer(container, zIndex, colors, alpha) {\n    var _this = _super.call(this, container, 'text', zIndex, alpha, colors) || this;\n\n    _this._characterOverlapCache = {};\n    _this._state = new GridCache_1.GridCache();\n    return _this;\n  }\n\n  TextRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {\n    _super.prototype.resize.call(this, terminal, dim, charSizeChanged);\n\n    var terminalFont = this._getFont(terminal, false);\n\n    if (this._characterWidth !== dim.scaledCharWidth || this._characterFont !== terminalFont) {\n      this._characterWidth = dim.scaledCharWidth;\n      this._characterFont = terminalFont;\n      this._characterOverlapCache = {};\n    }\n\n    this._state.clear();\n\n    this._state.resize(terminal.cols, terminal.rows);\n  };\n\n  TextRenderLayer.prototype.reset = function (terminal) {\n    this._state.clear();\n\n    this.clearAll();\n  };\n\n  TextRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {\n    if (this._state.cache.length === 0) {\n      return;\n    }\n\n    for (var y = startRow; y <= endRow; y++) {\n      var row = y + terminal.buffer.ydisp;\n      var line = terminal.buffer.lines.get(row);\n      this.clearCells(0, y, terminal.cols, 1);\n\n      for (var x = 0; x < terminal.cols; x++) {\n        var charData = line[x];\n        var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];\n        var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];\n        var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];\n        var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];\n\n        if (width === 0) {\n          continue;\n        }\n\n        if (code === 32) {\n          if (x > 0) {\n            var previousChar = line[x - 1];\n\n            if (this._isOverlapping(previousChar)) {\n              continue;\n            }\n          }\n        }\n\n        var flags = attr >> 18;\n        var bg = attr & 0x1ff;\n        var isDefaultBackground = bg >= 256;\n        var isInvisible = flags & Types_1.FLAGS.INVISIBLE;\n        var isInverted = flags & Types_1.FLAGS.INVERSE;\n\n        if (!code || code === 32 && isDefaultBackground && !isInverted || isInvisible) {\n          continue;\n        }\n\n        if (width !== 0 && this._isOverlapping(charData)) {\n          if (x < line.length - 1 && line[x + 1][Buffer_1.CHAR_DATA_CODE_INDEX] === 32) {\n            width = 2;\n          }\n        }\n\n        var fg = attr >> 9 & 0x1ff;\n\n        if (isInverted) {\n          var temp = bg;\n          bg = fg;\n          fg = temp;\n\n          if (fg === 256) {\n            fg = BaseRenderLayer_1.INVERTED_DEFAULT_COLOR;\n          }\n\n          if (bg === 257) {\n            bg = BaseRenderLayer_1.INVERTED_DEFAULT_COLOR;\n          }\n        }\n\n        if (width === 2) {}\n\n        if (bg < 256) {\n          this._ctx.save();\n\n          this._ctx.fillStyle = bg === BaseRenderLayer_1.INVERTED_DEFAULT_COLOR ? this._colors.foreground : this._colors.ansi[bg];\n          this.fillCells(x, y, width, 1);\n\n          this._ctx.restore();\n        }\n\n        this._ctx.save();\n\n        if (flags & Types_1.FLAGS.BOLD) {\n          this._ctx.font = this._getFont(terminal, true);\n\n          if (fg < 8) {\n            fg += 8;\n          }\n        }\n\n        if (flags & Types_1.FLAGS.UNDERLINE) {\n          if (fg === BaseRenderLayer_1.INVERTED_DEFAULT_COLOR) {\n            this._ctx.fillStyle = this._colors.background;\n          } else if (fg < 256) {\n            this._ctx.fillStyle = this._colors.ansi[fg];\n          } else {\n            this._ctx.fillStyle = this._colors.foreground;\n          }\n\n          this.fillBottomLineAtCells(x, y);\n        }\n\n        this.drawChar(terminal, char, code, width, x, y, fg, bg, !!(flags & Types_1.FLAGS.BOLD), !!(flags & Types_1.FLAGS.DIM));\n\n        this._ctx.restore();\n      }\n    }\n  };\n\n  TextRenderLayer.prototype.onOptionsChanged = function (terminal) {\n    this.setTransparency(terminal, terminal.options.allowTransparency);\n  };\n\n  TextRenderLayer.prototype._isOverlapping = function (charData) {\n    if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] !== 1) {\n      return false;\n    }\n\n    var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];\n\n    if (code < 256) {\n      return false;\n    }\n\n    var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];\n\n    if (this._characterOverlapCache.hasOwnProperty(char)) {\n      return this._characterOverlapCache[char];\n    }\n\n    this._ctx.save();\n\n    this._ctx.font = this._characterFont;\n\n    var overlaps = Math.floor(this._ctx.measureText(char).width) > this._characterWidth;\n\n    this._ctx.restore();\n\n    this._characterOverlapCache[char] = overlaps;\n    return overlaps;\n  };\n\n  TextRenderLayer.prototype._clearChar = function (x, y) {\n    var colsToClear = 1;\n    var state = this._state.cache[x][y];\n\n    if (state && state[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {\n      colsToClear = 2;\n    }\n\n    this.clearCells(x, y, colsToClear, 1);\n  };\n\n  return TextRenderLayer;\n}(BaseRenderLayer_1.BaseRenderLayer);\n\nexports.TextRenderLayer = TextRenderLayer;","map":null,"metadata":{},"sourceType":"script"}