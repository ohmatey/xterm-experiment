{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.attach = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function attach(term, socket, bidirectional, buffered) {\n        var addonTerminal = term;\n        bidirectional = typeof bidirectional === 'undefined' ? true : bidirectional;\n        addonTerminal.__socket = socket;\n\n        addonTerminal.__flushBuffer = function () {\n          addonTerminal.write(addonTerminal.__attachSocketBuffer);\n          addonTerminal.__attachSocketBuffer = null;\n        };\n\n        addonTerminal.__pushToBuffer = function (data) {\n          if (addonTerminal.__attachSocketBuffer) {\n            addonTerminal.__attachSocketBuffer += data;\n          } else {\n            addonTerminal.__attachSocketBuffer = data;\n            setTimeout(addonTerminal.__flushBuffer, 10);\n          }\n        };\n\n        var myTextDecoder;\n\n        addonTerminal.__getMessage = function (ev) {\n          var str;\n\n          if (typeof ev.data === 'object') {\n            if (ev.data instanceof ArrayBuffer) {\n              if (!myTextDecoder) {\n                myTextDecoder = new TextDecoder();\n              }\n\n              str = myTextDecoder.decode(ev.data);\n            } else {\n              throw 'TODO: handle Blob?';\n            }\n          }\n\n          if (buffered) {\n            addonTerminal.__pushToBuffer(str || ev.data);\n          } else {\n            addonTerminal.write(str || ev.data);\n          }\n        };\n\n        addonTerminal.__sendData = function (data) {\n          if (socket.readyState !== 1) {\n            return;\n          }\n\n          socket.send(data);\n        };\n\n        socket.addEventListener('message', addonTerminal.__getMessage);\n\n        if (bidirectional) {\n          addonTerminal.on('data', addonTerminal.__sendData);\n        }\n\n        socket.addEventListener('close', function () {\n          return detach(addonTerminal, socket);\n        });\n        socket.addEventListener('error', function () {\n          return detach(addonTerminal, socket);\n        });\n      }\n\n      exports.attach = attach;\n\n      function detach(term, socket) {\n        var addonTerminal = term;\n        addonTerminal.off('data', addonTerminal.__sendData);\n        socket = typeof socket === 'undefined' ? addonTerminal.__socket : socket;\n\n        if (socket) {\n          socket.removeEventListener('message', addonTerminal.__getMessage);\n        }\n\n        delete addonTerminal.__socket;\n      }\n\n      exports.detach = detach;\n\n      function apply(terminalConstructor) {\n        terminalConstructor.prototype.attach = function (socket, bidirectional, buffered) {\n          attach(this, socket, bidirectional, buffered);\n        };\n\n        terminalConstructor.prototype.detach = function (socket) {\n          detach(this, socket);\n        };\n      }\n\n      exports.apply = apply;\n    }, {}]\n  }, {}, [1])(1);\n});","map":null,"metadata":{},"sourceType":"script"}